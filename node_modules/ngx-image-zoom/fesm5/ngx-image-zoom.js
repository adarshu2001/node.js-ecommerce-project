import { __decorate } from 'tslib';
import { EventEmitter, Renderer2, ViewChild, Output, Input, Component, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

var NgxImageZoomComponent = /** @class */ (function () {
    function NgxImageZoomComponent(renderer) {
        this.renderer = renderer;
        this.zoomScroll = new EventEmitter();
        this.zoomPosition = new EventEmitter();
        this.enableLens = false;
        this.lensBorderRadius = 0;
        this.lensWidth = 100;
        this.lensHeight = 100;
        this.zoomMode = 'hover';
        this.magnification = 1;
        this.enableScrollZoom = false;
        this.scrollStepSize = 0.1;
        this.circularLens = false;
        this.maxZoomRatio = 2;
        this.zoomingEnabled = false;
        this.zoomFrozen = false;
        this.isReady = false;
        this.thumbImageLoaded = false;
        this.fullImageLoaded = false;
        this.eventListeners = [];
    }
    NgxImageZoomComponent_1 = NgxImageZoomComponent;
    Object.defineProperty(NgxImageZoomComponent.prototype, "setThumbImage", {
        set: function (thumbImage) {
            this.thumbImageLoaded = false;
            this.isReady = false;
            this.thumbImage = thumbImage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setFullImage", {
        set: function (fullImage) {
            this.fullImageLoaded = false;
            this.isReady = false;
            this.fullImage = fullImage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setZoomMode", {
        set: function (zoomMode) {
            if (NgxImageZoomComponent_1.validZoomModes.some(function (m) { return m === zoomMode; })) {
                this.zoomMode = zoomMode;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setMagnification", {
        set: function (magnification) {
            this.magnification = Number(magnification) || this.magnification;
            this.zoomScroll.emit(this.magnification);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setMinZoomRatio", {
        set: function (minZoomRatio) {
            var ratio = Number(minZoomRatio) || this.minZoomRatio || this.baseRatio || 0;
            this.minZoomRatio = Math.max(ratio, this.baseRatio || 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setMaxZoomRatio", {
        set: function (maxZoomRatio) {
            this.maxZoomRatio = Number(maxZoomRatio) || this.maxZoomRatio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setScrollStepSize", {
        set: function (stepSize) {
            this.scrollStepSize = Number(stepSize) || this.scrollStepSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setEnableLens", {
        set: function (enable) {
            this.enableLens = Boolean(enable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setLensWidth", {
        set: function (width) {
            this.lensWidth = Number(width) || this.lensWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setLensHeight", {
        set: function (height) {
            this.lensHeight = Number(height) || this.lensHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setCircularLens", {
        set: function (enable) {
            this.circularLens = Boolean(enable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxImageZoomComponent.prototype, "setEnableScrollZoom", {
        set: function (enable) {
            this.enableScrollZoom = Boolean(enable);
        },
        enumerable: true,
        configurable: true
    });
    NgxImageZoomComponent.prototype.ngOnInit = function () {
        this.setUpEventListeners();
    };
    NgxImageZoomComponent.prototype.ngOnChanges = function () {
        if (this.enableLens) {
            if (this.circularLens) {
                this.lensBorderRadius = this.lensWidth / 2;
            }
            else {
                this.lensBorderRadius = 0;
            }
        }
        this.calculateRatioAndOffset();
        this.calculateImageAndLensPosition();
    };
    NgxImageZoomComponent.prototype.ngOnDestroy = function () {
        this.eventListeners.forEach(function (destroyFn) { return destroyFn(); });
    };
    /**
     * Template helper methods
     */
    NgxImageZoomComponent.prototype.onThumbImageLoaded = function () {
        this.thumbImageLoaded = true;
        this.checkImagesLoaded();
    };
    NgxImageZoomComponent.prototype.onFullImageLoaded = function () {
        this.fullImageLoaded = true;
        this.checkImagesLoaded();
    };
    NgxImageZoomComponent.prototype.setUpEventListeners = function () {
        var _this = this;
        if (this.zoomMode === 'hover') {
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mouseenter', function (event) { return _this.hoverMouseEnter(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mouseleave', function () { return _this.hoverMouseLeave(); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mousemove', function (event) { return _this.hoverMouseMove(event); }));
        }
        else if (this.zoomMode === 'toggle') {
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'click', function (event) { return _this.toggleClick(event); }));
        }
        else if (this.zoomMode === 'click') {
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'click', function (event) { return _this.clickStarter(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mouseleave', function () { return _this.clickMouseLeave(); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mousemove', function (event) { return _this.clickMouseMove(event); }));
        }
        else if (this.zoomMode === 'hover-freeze') {
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mouseenter', function (event) { return _this.hoverFreezeMouseEnter(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mouseleave', function () { return _this.hoverFreezeMouseLeave(); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mousemove', function (event) { return _this.hoverFreezeMouseMove(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'click', function (event) { return _this.hoverFreezeClick(event); }));
        }
        if (this.enableScrollZoom) {
            // Chrome: 'mousewheel', Firefox: 'DOMMouseScroll', IE: 'onmousewheel'
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'mousewheel', function (event) { return _this.onMouseWheel(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'DOMMouseScroll', function (event) { return _this.onMouseWheel(event); }));
            this.eventListeners.push(this.renderer.listen(this.zoomContainer.nativeElement, 'onmousewheel', function (event) { return _this.onMouseWheel(event); }));
        }
        if (this.enableLens && this.circularLens) {
            this.lensBorderRadius = this.lensWidth / 2;
        }
    };
    NgxImageZoomComponent.prototype.checkImagesLoaded = function () {
        this.calculateRatioAndOffset();
        if (this.thumbImageLoaded && this.fullImageLoaded) {
            this.calculateImageAndLensPosition();
            this.isReady = true;
        }
    };
    /**
     * Zoom position setters
     */
    NgxImageZoomComponent.prototype.setZoomPosition = function (left, top) {
        this.latestMouseLeft = Number(left) || this.latestMouseLeft;
        this.latestMouseTop = Number(top) || this.latestMouseTop;
        var c = {
            x: this.latestMouseLeft,
            y: this.latestMouseTop
        };
        this.zoomPosition.emit(c);
    };
    /**
     * Mouse wheel event
     */
    NgxImageZoomComponent.prototype.onMouseWheel = function (event) {
        // Don't eat events if zooming isn't active
        if (!this.zoomingEnabled || this.zoomFrozen) {
            return;
        }
        event = window.event || event; // old IE
        var direction = Math.max(Math.min((event.wheelDelta || -event.detail), 1), -1);
        if (direction > 0) {
            // up
            this.setMagnification = Math.min(this.magnification + this.scrollStepSize, this.maxZoomRatio);
        }
        else {
            // down
            this.setMagnification = Math.max(this.magnification - this.scrollStepSize, this.minZoomRatio);
        }
        this.calculateRatio();
        this.calculateZoomPosition(event);
        // Prevent scrolling on page.
        event.returnValue = false; // IE
        if (event.preventDefault) {
            event.preventDefault(); // Chrome & FF
        }
    };
    /**
     * Hover mode
     */
    NgxImageZoomComponent.prototype.hoverMouseEnter = function (event) {
        this.zoomOn(event);
    };
    NgxImageZoomComponent.prototype.hoverMouseLeave = function () {
        this.zoomOff();
    };
    NgxImageZoomComponent.prototype.hoverMouseMove = function (event) {
        this.calculateZoomPosition(event);
    };
    /**
     * Toggle mode
     */
    NgxImageZoomComponent.prototype.toggleClick = function (event) {
        if (this.zoomingEnabled) {
            this.zoomOff();
        }
        else {
            this.zoomOn(event);
        }
    };
    /**
     * Click mode
     */
    NgxImageZoomComponent.prototype.clickStarter = function (event) {
        if (this.zoomingEnabled === false) {
            this.zoomOn(event);
        }
    };
    NgxImageZoomComponent.prototype.clickMouseLeave = function () {
        this.zoomOff();
    };
    NgxImageZoomComponent.prototype.clickMouseMove = function (event) {
        if (this.zoomingEnabled) {
            this.calculateZoomPosition(event);
        }
    };
    /**
     * Hover freeze mode
     */
    NgxImageZoomComponent.prototype.hoverFreezeMouseEnter = function (event) {
        if (this.zoomingEnabled && !this.zoomFrozen) {
            this.zoomOn(event);
        }
    };
    NgxImageZoomComponent.prototype.hoverFreezeMouseLeave = function () {
        if (this.zoomingEnabled && !this.zoomFrozen) {
            this.zoomOff();
        }
    };
    NgxImageZoomComponent.prototype.hoverFreezeMouseMove = function (event) {
        if (this.zoomingEnabled && !this.zoomFrozen) {
            this.calculateZoomPosition(event);
        }
    };
    NgxImageZoomComponent.prototype.hoverFreezeClick = function (event) {
        if (this.zoomingEnabled && this.zoomFrozen) {
            this.zoomFrozen = false;
            this.zoomOff();
        }
        else if (this.zoomingEnabled) {
            this.zoomFrozen = true;
        }
        else {
            this.zoomOn(event);
        }
    };
    /**
     * Private helper methods
     */
    NgxImageZoomComponent.prototype.zoomOn = function (event) {
        if (this.isReady) {
            this.zoomingEnabled = true;
            this.calculateRatioAndOffset();
            this.display = 'block';
            this.calculateZoomPosition(event);
        }
    };
    NgxImageZoomComponent.prototype.zoomOff = function () {
        this.zoomingEnabled = false;
        this.display = 'none';
    };
    NgxImageZoomComponent.prototype.calculateZoomPosition = function (event) {
        var newLeft = Math.max(Math.min(event.offsetX, this.thumbWidth), 0);
        var newTop = Math.max(Math.min(event.offsetY, this.thumbHeight), 0);
        this.setZoomPosition(newLeft, newTop);
        this.calculateImageAndLensPosition();
    };
    NgxImageZoomComponent.prototype.calculateImageAndLensPosition = function () {
        var lensLeftMod = 0;
        var lensTopMod = 0;
        if (this.enableLens) {
            lensLeftMod = this.lensLeft = this.latestMouseLeft - this.lensWidth / 2;
            lensTopMod = this.lensTop = this.latestMouseTop - this.lensHeight / 2;
        }
        this.fullImageLeft = (this.latestMouseLeft * -this.xRatio) - lensLeftMod;
        this.fullImageTop = (this.latestMouseTop * -this.yRatio) - lensTopMod;
    };
    NgxImageZoomComponent.prototype.calculateRatioAndOffset = function () {
        this.thumbWidth = this.imageThumbnail.nativeElement.width;
        this.thumbHeight = this.imageThumbnail.nativeElement.height;
        // If lens is disabled, set lens size to equal thumb size and position it on top of the thumb
        if (!this.enableLens) {
            this.lensWidth = this.thumbWidth;
            this.lensHeight = this.thumbHeight;
            this.lensLeft = 0;
            this.lensTop = 0;
        }
        // getBoundingClientRect() ? https://stackoverflow.com/a/44008873
        this.offsetTop = this.imageThumbnail.nativeElement.getBoundingClientRect().top;
        this.offsetLeft = this.imageThumbnail.nativeElement.getBoundingClientRect().left;
        if (this.fullImage === undefined) {
            this.fullImage = this.thumbImage;
        }
        if (this.fullImageLoaded) {
            this.fullWidth = this.fullSizeImage.nativeElement.naturalWidth;
            this.fullHeight = this.fullSizeImage.nativeElement.naturalHeight;
            this.baseRatio = Math.max((this.thumbWidth / this.fullWidth), (this.thumbHeight / this.fullHeight));
            // Don't allow zooming to smaller than thumbnail size
            this.minZoomRatio = Math.max(this.minZoomRatio || 0, this.baseRatio || 0);
            this.calculateRatio();
        }
    };
    NgxImageZoomComponent.prototype.calculateRatio = function () {
        this.magnifiedWidth = (this.fullWidth * this.magnification);
        this.magnifiedHeight = (this.fullHeight * this.magnification);
        this.xRatio = (this.magnifiedWidth - this.thumbWidth) / this.thumbWidth;
        this.yRatio = (this.magnifiedHeight - this.thumbHeight) / this.thumbHeight;
    };
    var NgxImageZoomComponent_1;
    NgxImageZoomComponent.validZoomModes = ['hover', 'toggle', 'click', 'hover-freeze'];
    NgxImageZoomComponent.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    __decorate([
        ViewChild('zoomContainer', { static: true })
    ], NgxImageZoomComponent.prototype, "zoomContainer", void 0);
    __decorate([
        ViewChild('imageThumbnail', { static: true })
    ], NgxImageZoomComponent.prototype, "imageThumbnail", void 0);
    __decorate([
        ViewChild('fullSizeImage', { static: true })
    ], NgxImageZoomComponent.prototype, "fullSizeImage", void 0);
    __decorate([
        Output()
    ], NgxImageZoomComponent.prototype, "zoomScroll", void 0);
    __decorate([
        Output()
    ], NgxImageZoomComponent.prototype, "zoomPosition", void 0);
    __decorate([
        Input('thumbImage')
    ], NgxImageZoomComponent.prototype, "setThumbImage", null);
    __decorate([
        Input('fullImage')
    ], NgxImageZoomComponent.prototype, "setFullImage", null);
    __decorate([
        Input('zoomMode')
    ], NgxImageZoomComponent.prototype, "setZoomMode", null);
    __decorate([
        Input('magnification')
    ], NgxImageZoomComponent.prototype, "setMagnification", null);
    __decorate([
        Input('minZoomRatio')
    ], NgxImageZoomComponent.prototype, "setMinZoomRatio", null);
    __decorate([
        Input('maxZoomRatio')
    ], NgxImageZoomComponent.prototype, "setMaxZoomRatio", null);
    __decorate([
        Input('scrollStepSize')
    ], NgxImageZoomComponent.prototype, "setScrollStepSize", null);
    __decorate([
        Input('enableLens')
    ], NgxImageZoomComponent.prototype, "setEnableLens", null);
    __decorate([
        Input('lensWidth')
    ], NgxImageZoomComponent.prototype, "setLensWidth", null);
    __decorate([
        Input('lensHeight')
    ], NgxImageZoomComponent.prototype, "setLensHeight", null);
    __decorate([
        Input('circularLens')
    ], NgxImageZoomComponent.prototype, "setCircularLens", null);
    __decorate([
        Input('enableScrollZoom')
    ], NgxImageZoomComponent.prototype, "setEnableScrollZoom", null);
    NgxImageZoomComponent = NgxImageZoomComponent_1 = __decorate([
        Component({
            selector: 'lib-ngx-image-zoom',
            template: "<div #zoomContainer class=\"ngxImageZoomContainer\"\n     [style.width.px]=\"this.thumbWidth\" [style.height.px]=\"this.thumbHeight\">\n\n  <img #imageThumbnail class=\"ngxImageZoomThumbnail\" [src]=\"thumbImage\" (load)=\"onThumbImageLoaded()\"/>\n\n  <div [ngClass]=\"{'ngxImageZoomFullContainer': true, 'ngxImageZoomLensEnabled': this.enableLens}\"\n       [style.display]=\"this.display\"\n       [style.top.px]=\"this.lensTop\"\n       [style.left.px]=\"this.lensLeft\"\n       [style.width.px]=\"this.lensWidth\"\n       [style.height.px]=\"this.lensHeight\"\n       [style.border-radius.px]=\"this.lensBorderRadius\"\n  >\n    <img #fullSizeImage class=\"ngxImageZoomFull\" [src]=\"fullImage\"\n         (load)=\"onFullImageLoaded()\"\n         [style.display]=\"this.display\"\n         [style.top.px]=\"this.fullImageTop\"\n         [style.left.px]=\"this.fullImageLeft\"\n         [style.width.px]=\"this.magnifiedWidth\"\n         [style.height.px]=\"this.magnifiedHeight\"\n    />\n  </div>\n</div>\n",
            styles: [".ngxImageZoomContainer{position:relative;margin:auto;overflow:hidden;pointer-events:none}.ngxImageZoomThumbnail{pointer-events:all}.ngxImageZoomFull{position:absolute;max-width:none;max-height:none;display:none;pointer-events:none}.ngxImageZoomFullContainer{position:absolute;overflow:hidden;pointer-events:none}.ngxImageZoomFullContainer.ngxImageZoomLensEnabled{border:2px solid red;cursor:crosshair;pointer-events:none}"]
        })
    ], NgxImageZoomComponent);
    return NgxImageZoomComponent;
}());

var NgxImageZoomModule = /** @class */ (function () {
    function NgxImageZoomModule() {
    }
    NgxImageZoomModule = __decorate([
        NgModule({
            declarations: [
                NgxImageZoomComponent,
            ],
            imports: [
                CommonModule,
            ],
            exports: [
                NgxImageZoomComponent
            ]
        })
    ], NgxImageZoomModule);
    return NgxImageZoomModule;
}());

/*
 * Public API Surface of ngx-image-zoom
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxImageZoomComponent, NgxImageZoomModule };
//# sourceMappingURL=ngx-image-zoom.js.map
